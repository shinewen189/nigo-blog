(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{485:function(t,i,s){"use strict";s.r(i);var n=s(4),e=Object(n.a)({},(function(){var t=this,i=t.$createElement,s=t._self._c||i;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[t._v("函数的 this 关键字在 JavaScript 中的表现略有不同，此外，在严格模式和非严格模式之间也会有一些差别")]),t._v(" "),s("p",[t._v("在绝大多数情况下，函数的调用方式决定了 this 的值（运行时绑定）")]),t._v(" "),s("p",[t._v("this 关键字是函数运行时自动生成的一个内部对象，只能在函数内部使用，总指向调用它的对象")]),t._v(" "),s("p",[t._v("我对this的理解")]),t._v(" "),s("ol",[s("li",[t._v("函数内的this是指向调用者，即是当前对象")]),t._v(" "),s("li",[t._v("在window坏境下全局定义函数this是指向window对象")]),t._v(" "),s("li",[t._v("在一个对象的方法里嵌套函数和或者使用回调函数它们的this会指向window对象，不属于当前对象的方法， ，在es5我们要在方法和回调函数内调用this，必须要先保存this")]),t._v(" "),s("li",[t._v("es6新增的箭头函数解决3的问题 ，没有this的指向，不能当做构造函数使用")])])])}),[],!1,null,null,null);i.default=e.exports}}]);